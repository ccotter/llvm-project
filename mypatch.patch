diff --git a/clang-tools-extra/clang-tidy/modernize/LoopConvertCheck.cpp b/clang-tools-extra/clang-tidy/modernize/LoopConvertCheck.cpp
index 3033fcbd3ee4..eabba6e6cf81 100644
--- a/clang-tools-extra/clang-tidy/modernize/LoopConvertCheck.cpp
+++ b/clang-tools-extra/clang-tidy/modernize/LoopConvertCheck.cpp
@@ -1,972 +1,973 @@
 //===--- LoopConvertCheck.cpp - clang-tidy---------------------------------===//
 //
 // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
 // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 //
 //===----------------------------------------------------------------------===//
 
 #include "LoopConvertCheck.h"
 #include "clang/AST/ASTContext.h"
 #include "clang/ASTMatchers/ASTMatchFinder.h"
 #include "clang/Basic/LLVM.h"
 #include "clang/Basic/LangOptions.h"
 #include "clang/Basic/SourceLocation.h"
 #include "clang/Basic/SourceManager.h"
 #include "clang/Lex/Lexer.h"
 #include "llvm/ADT/ArrayRef.h"
 #include "llvm/ADT/SmallVector.h"
 #include "llvm/ADT/StringRef.h"
 #include "llvm/Support/Casting.h"
 #include "llvm/Support/raw_ostream.h"
 #include <cassert>
 #include <cstring>
 #include <utility>
 
 using namespace clang::ast_matchers;
 using namespace llvm;
 
 namespace clang {
 namespace tidy {
 
 template <> struct OptionEnumMapping<modernize::Confidence::Level> {
   static llvm::ArrayRef<std::pair<modernize::Confidence::Level, StringRef>>
   getEnumMapping() {
     static constexpr std::pair<modernize::Confidence::Level, StringRef>
         Mapping[] = {{modernize::Confidence::CL_Reasonable, "reasonable"},
                      {modernize::Confidence::CL_Safe, "safe"},
                      {modernize::Confidence::CL_Risky, "risky"}};
     return makeArrayRef(Mapping);
   }
 };
 
 template <> struct OptionEnumMapping<modernize::VariableNamer::NamingStyle> {
   static llvm::ArrayRef<
       std::pair<modernize::VariableNamer::NamingStyle, StringRef>>
   getEnumMapping() {
     static constexpr std::pair<modernize::VariableNamer::NamingStyle, StringRef>
         Mapping[] = {{modernize::VariableNamer::NS_CamelCase, "CamelCase"},
                      {modernize::VariableNamer::NS_CamelBack, "camelBack"},
                      {modernize::VariableNamer::NS_LowerCase, "lower_case"},
                      {modernize::VariableNamer::NS_UpperCase, "UPPER_CASE"}};
     return makeArrayRef(Mapping);
   }
 };
 
 namespace modernize {
 
 static const char LoopNameArray[] = "forLoopArray";
 static const char LoopNameIterator[] = "forLoopIterator";
 static const char LoopNameReverseIterator[] = "forLoopReverseIterator";
 static const char LoopNamePseudoArray[] = "forLoopPseudoArray";
 static const char ConditionBoundName[] = "conditionBound";
 static const char InitVarName[] = "initVar";
 static const char BeginCallName[] = "beginCall";
 static const char EndCallName[] = "endCall";
 static const char EndVarName[] = "endVar";
 static const char DerefByValueResultName[] = "derefByValueResult";
 static const char DerefByRefResultName[] = "derefByRefResult";
 
 static const StatementMatcher integerComparisonMatcher() {
   return expr(ignoringParenImpCasts(
       declRefExpr(to(varDecl(equalsBoundNode(InitVarName))))));
 }
 
 static const DeclarationMatcher initToZeroMatcher() {
   return varDecl(
              hasInitializer(ignoringParenImpCasts(integerLiteral(equals(0)))))
       .bind(InitVarName);
 }
 
 static const StatementMatcher incrementVarMatcher() {
   return declRefExpr(to(varDecl(equalsBoundNode(InitVarName))));
 }
 
 static StatementMatcher
 arrayConditionMatcher(internal::Matcher<Expr> LimitExpr) {
   return binaryOperator(
       anyOf(allOf(hasOperatorName("<"), hasLHS(integerComparisonMatcher()),
                   hasRHS(LimitExpr)),
             allOf(hasOperatorName(">"), hasLHS(LimitExpr),
                   hasRHS(integerComparisonMatcher())),
             allOf(hasOperatorName("!="),
                   hasOperands(integerComparisonMatcher(), LimitExpr))));
 }
 
 /// The matcher for loops over arrays.
 /// \code
 ///   for (int i = 0; i < 3 + 2; ++i) { ... }
 /// \endcode
 /// The following string identifiers are bound to these parts of the AST:
 ///   ConditionBoundName: '3 + 2' (as an Expr)
 ///   InitVarName: 'i' (as a VarDecl)
 ///   LoopName: The entire for loop (as a ForStmt)
 ///
 /// Client code will need to make sure that:
 ///   - The index variable is only used as an array index.
 ///   - All arrays indexed by the loop are the same.
 StatementMatcher makeArrayLoopMatcher() {
   StatementMatcher ArrayBoundMatcher =
       expr(hasType(isInteger())).bind(ConditionBoundName);
 
   return forStmt(unless(isInTemplateInstantiation()),
                  hasLoopInit(declStmt(hasSingleDecl(initToZeroMatcher()))),
                  hasCondition(arrayConditionMatcher(ArrayBoundMatcher)),
                  hasIncrement(
                      unaryOperator(hasOperatorName("++"),
                                    hasUnaryOperand(incrementVarMatcher()))))
       .bind(LoopNameArray);
 }
 
 /// The matcher used for iterator-based for loops.
 ///
 /// This matcher is more flexible than array-based loops. It will match
 /// catch loops of the following textual forms (regardless of whether the
 /// iterator type is actually a pointer type or a class type):
 ///
 /// \code
 ///   for (containerType::iterator it = container.begin(),
 ///        e = createIterator(); it != e; ++it) { ... }
 ///   for (containerType::iterator it = container.begin();
 ///        it != anotherContainer.end(); ++it) { ... }
 /// \endcode
 /// The following string identifiers are bound to the parts of the AST:
 ///   InitVarName: 'it' (as a VarDecl)
 ///   LoopName: The entire for loop (as a ForStmt)
 ///   In the first example only:
 ///     EndVarName: 'e' (as a VarDecl)
 ///   In the second example only:
 ///     EndCallName: 'container.end()' (as a CXXMemberCallExpr)
 ///
 /// Client code will need to make sure that:
 ///   - The two containers on which 'begin' and 'end' are called are the same.
 StatementMatcher makeIteratorLoopMatcher(bool IsReverse) {
 
   auto BeginNameMatcher = IsReverse ? hasAnyName("rbegin", "crbegin")
                                     : hasAnyName("begin", "cbegin");
 
   auto EndNameMatcher =
       IsReverse ? hasAnyName("rend", "crend") : hasAnyName("end", "cend");
 
   StatementMatcher BeginCallMatcher =
       cxxMemberCallExpr(argumentCountIs(0),
                         callee(cxxMethodDecl(BeginNameMatcher)))
           .bind(BeginCallName);
 
   DeclarationMatcher InitDeclMatcher =
       varDecl(hasInitializer(anyOf(ignoringParenImpCasts(BeginCallMatcher),
                                    materializeTemporaryExpr(
                                        ignoringParenImpCasts(BeginCallMatcher)),
                                    hasDescendant(BeginCallMatcher))))
           .bind(InitVarName);
 
   DeclarationMatcher EndDeclMatcher =
       varDecl(hasInitializer(anything())).bind(EndVarName);
 
   StatementMatcher EndCallMatcher = cxxMemberCallExpr(
       argumentCountIs(0), callee(cxxMethodDecl(EndNameMatcher)));
 
   StatementMatcher IteratorBoundMatcher =
       expr(anyOf(ignoringParenImpCasts(
                      declRefExpr(to(varDecl(equalsBoundNode(EndVarName))))),
                  ignoringParenImpCasts(expr(EndCallMatcher).bind(EndCallName)),
                  materializeTemporaryExpr(ignoringParenImpCasts(
                      expr(EndCallMatcher).bind(EndCallName)))));
 
   StatementMatcher IteratorComparisonMatcher = expr(ignoringParenImpCasts(
       declRefExpr(to(varDecl(equalsBoundNode(InitVarName))))));
 
   // This matcher tests that a declaration is a CXXRecordDecl that has an
   // overloaded operator*(). If the operator*() returns by value instead of by
   // reference then the return type is tagged with DerefByValueResultName.
   internal::Matcher<VarDecl> TestDerefReturnsByValue =
       hasType(hasUnqualifiedDesugaredType(
           recordType(hasDeclaration(cxxRecordDecl(hasMethod(cxxMethodDecl(
               hasOverloadedOperatorName("*"),
               anyOf(
                   // Tag the return type if it's by value.
                   returns(qualType(unless(hasCanonicalType(referenceType())))
                               .bind(DerefByValueResultName)),
                   returns(
                       // Skip loops where the iterator's operator* returns an
                       // rvalue reference. This is just weird.
                       qualType(unless(hasCanonicalType(rValueReferenceType())))
                           .bind(DerefByRefResultName))))))))));
 
   return forStmt(
              unless(isInTemplateInstantiation()),
              hasLoopInit(anyOf(declStmt(declCountIs(2),
                                         containsDeclaration(0, InitDeclMatcher),
                                         containsDeclaration(1, EndDeclMatcher)),
                                declStmt(hasSingleDecl(InitDeclMatcher)))),
              hasCondition(ignoringImplicit(binaryOperation(
                  hasOperatorName("!="), hasOperands(IteratorComparisonMatcher,
                                                     IteratorBoundMatcher)))),
              hasIncrement(anyOf(
                  unaryOperator(hasOperatorName("++"),
                                hasUnaryOperand(declRefExpr(
                                    to(varDecl(equalsBoundNode(InitVarName)))))),
                  cxxOperatorCallExpr(
                      hasOverloadedOperatorName("++"),
                      hasArgument(0, declRefExpr(to(
                                         varDecl(equalsBoundNode(InitVarName),
                                                 TestDerefReturnsByValue))))))))
       .bind(IsReverse ? LoopNameReverseIterator : LoopNameIterator);
 }
 
 /// The matcher used for array-like containers (pseudoarrays).
 ///
 /// This matcher is more flexible than array-based loops. It will match
 /// loops of the following textual forms (regardless of whether the
 /// iterator type is actually a pointer type or a class type):
 ///
 /// \code
 ///   for (int i = 0, j = container.size(); i < j; ++i) { ... }
 ///   for (int i = 0; i < container.size(); ++i) { ... }
 /// \endcode
 /// The following string identifiers are bound to the parts of the AST:
 ///   InitVarName: 'i' (as a VarDecl)
 ///   LoopName: The entire for loop (as a ForStmt)
 ///   In the first example only:
 ///     EndVarName: 'j' (as a VarDecl)
 ///   In the second example only:
 ///     EndCallName: 'container.size()' (as a CXXMemberCallExpr)
 ///
 /// Client code will need to make sure that:
 ///   - The containers on which 'size()' is called is the container indexed.
 ///   - The index variable is only used in overloaded operator[] or
 ///     container.at().
 ///   - The container's iterators would not be invalidated during the loop.
 StatementMatcher makePseudoArrayLoopMatcher() {
   // Test that the incoming type has a record declaration that has methods
   // called 'begin' and 'end'. If the incoming type is const, then make sure
   // these methods are also marked const.
   //
   // FIXME: To be completely thorough this matcher should also ensure the
   // return type of begin/end is an iterator that dereferences to the same as
   // what operator[] or at() returns. Such a test isn't likely to fail except
   // for pathological cases.
   //
   // FIXME: Also, a record doesn't necessarily need begin() and end(). Free
   // functions called begin() and end() taking the container as an argument
   // are also allowed.
   TypeMatcher RecordWithBeginEnd = qualType(anyOf(
-      qualType(
-          isConstQualified(),
-          hasUnqualifiedDesugaredType(recordType(hasDeclaration(cxxRecordDecl(
-              hasMethod(cxxMethodDecl(hasName("begin"), isConst())),
-              hasMethod(cxxMethodDecl(hasName("end"),
-                                      isConst()))))   // hasDeclaration
-                                                 ))), // qualType
+      qualType(isConstQualified(),
+               hasUnqualifiedDesugaredType(recordType(hasDeclaration(
+                   cxxRecordDecl(isSameOrDerivedFrom(cxxRecordDecl(
+                       hasMethod(cxxMethodDecl(hasName("begin"), isConst())),
+                       hasMethod(cxxMethodDecl(hasName("end"),
+                                               isConst())))))) // hasDeclaration
+                                                      ))),     // qualType
       qualType(unless(isConstQualified()),
                hasUnqualifiedDesugaredType(recordType(hasDeclaration(
-                   cxxRecordDecl(hasMethod(hasName("begin")),
-                                 hasMethod(hasName("end"))))))) // qualType
+                   cxxRecordDecl(isSameOrDerivedFrom(cxxRecordDecl(
+                       hasMethod(hasName("begin")),
+                       hasMethod(hasName("end"))))))))) // qualType
       ));
 
   StatementMatcher SizeCallMatcher = cxxMemberCallExpr(
       argumentCountIs(0), callee(cxxMethodDecl(hasAnyName("size", "length"))),
       on(anyOf(hasType(pointsTo(RecordWithBeginEnd)),
                hasType(RecordWithBeginEnd))));
 
   StatementMatcher EndInitMatcher =
       expr(anyOf(ignoringParenImpCasts(expr(SizeCallMatcher).bind(EndCallName)),
                  explicitCastExpr(hasSourceExpression(ignoringParenImpCasts(
                      expr(SizeCallMatcher).bind(EndCallName))))));
 
   DeclarationMatcher EndDeclMatcher =
       varDecl(hasInitializer(EndInitMatcher)).bind(EndVarName);
 
   StatementMatcher IndexBoundMatcher =
       expr(anyOf(ignoringParenImpCasts(
                      declRefExpr(to(varDecl(equalsBoundNode(EndVarName))))),
                  EndInitMatcher));
 
   return forStmt(unless(isInTemplateInstantiation()),
                  hasLoopInit(
                      anyOf(declStmt(declCountIs(2),
                                     containsDeclaration(0, initToZeroMatcher()),
                                     containsDeclaration(1, EndDeclMatcher)),
                            declStmt(hasSingleDecl(initToZeroMatcher())))),
                  hasCondition(arrayConditionMatcher(IndexBoundMatcher)),
                  hasIncrement(
                      unaryOperator(hasOperatorName("++"),
                                    hasUnaryOperand(incrementVarMatcher()))))
       .bind(LoopNamePseudoArray);
 }
 
 /// Determine whether Init appears to be an initializing an iterator.
 ///
 /// If it is, returns the object whose begin() or end() method is called, and
 /// the output parameter isArrow is set to indicate whether the initialization
 /// is called via . or ->.
 static const Expr *getContainerFromBeginEndCall(const Expr *Init, bool IsBegin,
                                                 bool *IsArrow, bool IsReverse) {
   // FIXME: Maybe allow declaration/initialization outside of the for loop.
   const auto *TheCall = dyn_cast_or_null<CXXMemberCallExpr>(
       digThroughConstructorsConversions(Init));
   if (!TheCall || TheCall->getNumArgs() != 0)
     return nullptr;
 
   const auto *Member = dyn_cast<MemberExpr>(TheCall->getCallee());
   if (!Member)
     return nullptr;
   StringRef Name = Member->getMemberDecl()->getName();
   if (!Name.consume_back(IsBegin ? "begin" : "end"))
     return nullptr;
   if (IsReverse && !Name.consume_back("r"))
     return nullptr;
   if (!Name.empty() && !Name.equals("c"))
     return nullptr;
 
   const Expr *SourceExpr = Member->getBase();
   if (!SourceExpr)
     return nullptr;
 
   *IsArrow = Member->isArrow();
   return SourceExpr;
 }
 
 /// Determines the container whose begin() and end() functions are called
 /// for an iterator-based loop.
 ///
 /// BeginExpr must be a member call to a function named "begin()", and EndExpr
 /// must be a member.
 static const Expr *findContainer(ASTContext *Context, const Expr *BeginExpr,
                                  const Expr *EndExpr,
                                  bool *ContainerNeedsDereference,
                                  bool IsReverse) {
   // Now that we know the loop variable and test expression, make sure they are
   // valid.
   bool BeginIsArrow = false;
   bool EndIsArrow = false;
   const Expr *BeginContainerExpr = getContainerFromBeginEndCall(
       BeginExpr, /*IsBegin=*/true, &BeginIsArrow, IsReverse);
   if (!BeginContainerExpr)
     return nullptr;
 
   const Expr *EndContainerExpr = getContainerFromBeginEndCall(
       EndExpr, /*IsBegin=*/false, &EndIsArrow, IsReverse);
   // Disallow loops that try evil things like this (note the dot and arrow):
   //  for (IteratorType It = Obj.begin(), E = Obj->end(); It != E; ++It) { }
   if (!EndContainerExpr || BeginIsArrow != EndIsArrow ||
       !areSameExpr(Context, EndContainerExpr, BeginContainerExpr))
     return nullptr;
 
   *ContainerNeedsDereference = BeginIsArrow;
   return BeginContainerExpr;
 }
 
 /// Obtain the original source code text from a SourceRange.
 static StringRef getStringFromRange(SourceManager &SourceMgr,
                                     const LangOptions &LangOpts,
                                     SourceRange Range) {
   if (SourceMgr.getFileID(Range.getBegin()) !=
       SourceMgr.getFileID(Range.getEnd())) {
     return StringRef(); // Empty string.
   }
 
   return Lexer::getSourceText(CharSourceRange(Range, true), SourceMgr,
                               LangOpts);
 }
 
 /// If the given expression is actually a DeclRefExpr or a MemberExpr,
 /// find and return the underlying ValueDecl; otherwise, return NULL.
 static const ValueDecl *getReferencedVariable(const Expr *E) {
   if (const DeclRefExpr *DRE = getDeclRef(E))
     return dyn_cast<VarDecl>(DRE->getDecl());
   if (const auto *Mem = dyn_cast<MemberExpr>(E->IgnoreParenImpCasts()))
     return dyn_cast<FieldDecl>(Mem->getMemberDecl());
   return nullptr;
 }
 
 /// Returns true when the given expression is a member expression
 /// whose base is `this` (implicitly or not).
 static bool isDirectMemberExpr(const Expr *E) {
   if (const auto *Member = dyn_cast<MemberExpr>(E->IgnoreParenImpCasts()))
     return isa<CXXThisExpr>(Member->getBase()->IgnoreParenImpCasts());
   return false;
 }
 
 /// Given an expression that represents an usage of an element from the
 /// containter that we are iterating over, returns false when it can be
 /// guaranteed this element cannot be modified as a result of this usage.
 static bool canBeModified(ASTContext *Context, const Expr *E) {
   if (E->getType().isConstQualified())
     return false;
   auto Parents = Context->getParents(*E);
   if (Parents.size() != 1)
     return true;
   if (const auto *Cast = Parents[0].get<ImplicitCastExpr>()) {
     if ((Cast->getCastKind() == CK_NoOp &&
          Context->hasSameType(Cast->getType(), E->getType().withConst())) ||
         (Cast->getCastKind() == CK_LValueToRValue &&
          !Cast->getType().isNull() && Cast->getType()->isFundamentalType()))
       return false;
   }
   // FIXME: Make this function more generic.
   return true;
 }
 
 /// Returns true when it can be guaranteed that the elements of the
 /// container are not being modified.
 static bool usagesAreConst(ASTContext *Context, const UsageResult &Usages) {
   for (const Usage &U : Usages) {
     // Lambda captures are just redeclarations (VarDecl) of the same variable,
     // not expressions. If we want to know if a variable that is captured by
     // reference can be modified in an usage inside the lambda's body, we need
     // to find the expression corresponding to that particular usage, later in
     // this loop.
     if (U.Kind != Usage::UK_CaptureByCopy && U.Kind != Usage::UK_CaptureByRef &&
         canBeModified(Context, U.Expression))
       return false;
   }
   return true;
 }
 
 /// Returns true if the elements of the container are never accessed
 /// by reference.
 static bool usagesReturnRValues(const UsageResult &Usages) {
   for (const auto &U : Usages) {
     if (U.Expression && !U.Expression->isPRValue())
       return false;
   }
   return true;
 }
 
 /// Returns true if the container is const-qualified.
 static bool containerIsConst(const Expr *ContainerExpr, bool Dereference) {
   if (const auto *VDec = getReferencedVariable(ContainerExpr)) {
     QualType CType = VDec->getType();
     if (Dereference) {
       if (!CType->isPointerType())
         return false;
       CType = CType->getPointeeType();
     }
     // If VDec is a reference to a container, Dereference is false,
     // but we still need to check the const-ness of the underlying container
     // type.
     CType = CType.getNonReferenceType();
     return CType.isConstQualified();
   }
   return false;
 }
 
 LoopConvertCheck::RangeDescriptor::RangeDescriptor()
     : ContainerNeedsDereference(false), DerefByConstRef(false),
       DerefByValue(false), NeedsReverseCall(false) {}
 
 LoopConvertCheck::LoopConvertCheck(StringRef Name, ClangTidyContext *Context)
     : ClangTidyCheck(Name, Context), TUInfo(new TUTrackingInfo),
       MaxCopySize(Options.get("MaxCopySize", 16ULL)),
       MinConfidence(Options.get("MinConfidence", Confidence::CL_Reasonable)),
       NamingStyle(Options.get("NamingStyle", VariableNamer::NS_CamelCase)),
       Inserter(Options.getLocalOrGlobal("IncludeStyle",
                                         utils::IncludeSorter::IS_LLVM),
                areDiagsSelfContained()),
       UseCxx20IfAvailable(Options.get("UseCxx20ReverseRanges", true)),
       ReverseFunction(Options.get("MakeReverseRangeFunction", "")),
       ReverseHeader(Options.get("MakeReverseRangeHeader", "")) {
 
   if (ReverseFunction.empty() && !ReverseHeader.empty()) {
     configurationDiag(
         "modernize-loop-convert: 'MakeReverseRangeHeader' is set but "
         "'MakeReverseRangeFunction' is not, disabling reverse loop "
         "transformation");
     UseReverseRanges = false;
   } else if (ReverseFunction.empty()) {
     UseReverseRanges = UseCxx20IfAvailable && getLangOpts().CPlusPlus20;
   } else {
     UseReverseRanges = true;
   }
 }
 
 void LoopConvertCheck::storeOptions(ClangTidyOptions::OptionMap &Opts) {
   Options.store(Opts, "MaxCopySize", MaxCopySize);
   Options.store(Opts, "MinConfidence", MinConfidence);
   Options.store(Opts, "NamingStyle", NamingStyle);
   Options.store(Opts, "IncludeStyle", Inserter.getStyle());
   Options.store(Opts, "UseCxx20ReverseRanges", UseCxx20IfAvailable);
   Options.store(Opts, "MakeReverseRangeFunction", ReverseFunction);
   Options.store(Opts, "MakeReverseRangeHeader", ReverseHeader);
 }
 
 void LoopConvertCheck::registerPPCallbacks(const SourceManager &SM,
                                            Preprocessor *PP,
                                            Preprocessor *ModuleExpanderPP) {
   Inserter.registerPreprocessor(PP);
 }
 
 void LoopConvertCheck::registerMatchers(MatchFinder *Finder) {
   Finder->addMatcher(traverse(TK_AsIs, makeArrayLoopMatcher()), this);
   Finder->addMatcher(traverse(TK_AsIs, makeIteratorLoopMatcher(false)), this);
   Finder->addMatcher(traverse(TK_AsIs, makePseudoArrayLoopMatcher()), this);
   if (UseReverseRanges)
     Finder->addMatcher(traverse(TK_AsIs, makeIteratorLoopMatcher(true)), this);
 }
 
 /// Given the range of a single declaration, such as:
 /// \code
 ///   unsigned &ThisIsADeclarationThatCanSpanSeveralLinesOfCode =
 ///       InitializationValues[I];
 ///   next_instruction;
 /// \endcode
 /// Finds the range that has to be erased to remove this declaration without
 /// leaving empty lines, by extending the range until the beginning of the
 /// next instruction.
 ///
 /// We need to delete a potential newline after the deleted alias, as
 /// clang-format will leave empty lines untouched. For all other formatting we
 /// rely on clang-format to fix it.
 void LoopConvertCheck::getAliasRange(SourceManager &SM, SourceRange &Range) {
   bool Invalid = false;
   const char *TextAfter =
       SM.getCharacterData(Range.getEnd().getLocWithOffset(1), &Invalid);
   if (Invalid)
     return;
   unsigned Offset = std::strspn(TextAfter, " \t\r\n");
   Range =
       SourceRange(Range.getBegin(), Range.getEnd().getLocWithOffset(Offset));
 }
 
 /// Computes the changes needed to convert a given for loop, and
 /// applies them.
 void LoopConvertCheck::doConversion(
     ASTContext *Context, const VarDecl *IndexVar,
     const ValueDecl *MaybeContainer, const UsageResult &Usages,
     const DeclStmt *AliasDecl, bool AliasUseRequired, bool AliasFromForInit,
     const ForStmt *Loop, RangeDescriptor Descriptor) {
   std::string VarName;
   bool VarNameFromAlias = (Usages.size() == 1) && AliasDecl;
   bool AliasVarIsRef = false;
   bool CanCopy = true;
   std::vector<FixItHint> FixIts;
   if (VarNameFromAlias) {
     const auto *AliasVar = cast<VarDecl>(AliasDecl->getSingleDecl());
     VarName = AliasVar->getName().str();
 
     // Use the type of the alias if it's not the same
     QualType AliasVarType = AliasVar->getType();
     assert(!AliasVarType.isNull() && "Type in VarDecl is null");
     if (AliasVarType->isReferenceType()) {
       AliasVarType = AliasVarType.getNonReferenceType();
       AliasVarIsRef = true;
     }
     if (Descriptor.ElemType.isNull() ||
         !Context->hasSameUnqualifiedType(AliasVarType, Descriptor.ElemType))
       Descriptor.ElemType = AliasVarType;
 
     // We keep along the entire DeclStmt to keep the correct range here.
     SourceRange ReplaceRange = AliasDecl->getSourceRange();
 
     std::string ReplacementText;
     if (AliasUseRequired) {
       ReplacementText = VarName;
     } else if (AliasFromForInit) {
       // FIXME: Clang includes the location of the ';' but only for DeclStmt's
       // in a for loop's init clause. Need to put this ';' back while removing
       // the declaration of the alias variable. This is probably a bug.
       ReplacementText = ";";
     } else {
       // Avoid leaving empty lines or trailing whitespaces.
       getAliasRange(Context->getSourceManager(), ReplaceRange);
     }
 
     FixIts.push_back(FixItHint::CreateReplacement(
         CharSourceRange::getTokenRange(ReplaceRange), ReplacementText));
     // No further replacements are made to the loop, since the iterator or index
     // was used exactly once - in the initialization of AliasVar.
   } else {
     VariableNamer Namer(&TUInfo->getGeneratedDecls(),
                         &TUInfo->getParentFinder().getStmtToParentStmtMap(),
                         Loop, IndexVar, MaybeContainer, Context, NamingStyle);
     VarName = Namer.createIndexName();
     // First, replace all usages of the array subscript expression with our new
     // variable.
     for (const auto &Usage : Usages) {
       std::string ReplaceText;
       SourceRange Range = Usage.Range;
       if (Usage.Expression) {
         // If this is an access to a member through the arrow operator, after
         // the replacement it must be accessed through the '.' operator.
         ReplaceText = Usage.Kind == Usage::UK_MemberThroughArrow ? VarName + "."
                                                                  : VarName;
         auto Parents = Context->getParents(*Usage.Expression);
         if (Parents.size() == 1) {
           if (const auto *Paren = Parents[0].get<ParenExpr>()) {
             // Usage.Expression will be replaced with the new index variable,
             // and parenthesis around a simple DeclRefExpr can always be
             // removed.
             Range = Paren->getSourceRange();
           } else if (const auto *UOP = Parents[0].get<UnaryOperator>()) {
             // If we are taking the address of the loop variable, then we must
             // not use a copy, as it would mean taking the address of the loop's
             // local index instead.
             // FIXME: This won't catch cases where the address is taken outside
             // of the loop's body (for instance, in a function that got the
             // loop's index as a const reference parameter), or where we take
             // the address of a member (like "&Arr[i].A.B.C").
             if (UOP->getOpcode() == UO_AddrOf)
               CanCopy = false;
           }
         }
       } else {
         // The Usage expression is only null in case of lambda captures (which
         // are VarDecl). If the index is captured by value, add '&' to capture
         // by reference instead.
         ReplaceText =
             Usage.Kind == Usage::UK_CaptureByCopy ? "&" + VarName : VarName;
       }
       TUInfo->getReplacedVars().insert(std::make_pair(Loop, IndexVar));
       FixIts.push_back(FixItHint::CreateReplacement(
           CharSourceRange::getTokenRange(Range), ReplaceText));
     }
   }
 
   // Now, we need to construct the new range expression.
   SourceRange ParenRange(Loop->getLParenLoc(), Loop->getRParenLoc());
 
   QualType Type = Context->getAutoDeductType();
   if (!Descriptor.ElemType.isNull() && Descriptor.ElemType->isFundamentalType())
     Type = Descriptor.ElemType.getUnqualifiedType();
   Type = Type.getDesugaredType(*Context);
 
   // If the new variable name is from the aliased variable, then the reference
   // type for the new variable should only be used if the aliased variable was
   // declared as a reference.
   bool IsCheapToCopy =
       !Descriptor.ElemType.isNull() &&
       Descriptor.ElemType.isTriviallyCopyableType(*Context) &&
       // TypeInfo::Width is in bits.
       Context->getTypeInfo(Descriptor.ElemType).Width <= 8 * MaxCopySize;
   bool UseCopy = CanCopy && ((VarNameFromAlias && !AliasVarIsRef) ||
                              (Descriptor.DerefByConstRef && IsCheapToCopy));
 
   if (!UseCopy) {
     if (Descriptor.DerefByConstRef) {
       Type = Context->getLValueReferenceType(Context->getConstType(Type));
     } else if (Descriptor.DerefByValue) {
       if (!IsCheapToCopy)
         Type = Context->getRValueReferenceType(Type);
     } else {
       Type = Context->getLValueReferenceType(Type);
     }
   }
 
   SmallString<128> Range;
   llvm::raw_svector_ostream Output(Range);
   Output << '(';
   Type.print(Output, getLangOpts());
   Output << ' ' << VarName << " : ";
   if (Descriptor.NeedsReverseCall)
     Output << getReverseFunction() << '(';
   if (Descriptor.ContainerNeedsDereference)
     Output << '*';
   Output << Descriptor.ContainerString;
   if (Descriptor.NeedsReverseCall)
     Output << "))";
   else
     Output << ')';
   FixIts.push_back(FixItHint::CreateReplacement(
       CharSourceRange::getTokenRange(ParenRange), Range));
 
   if (Descriptor.NeedsReverseCall && !getReverseHeader().empty()) {
     if (Optional<FixItHint> Insertion = Inserter.createIncludeInsertion(
             Context->getSourceManager().getFileID(Loop->getBeginLoc()),
             getReverseHeader()))
       FixIts.push_back(*Insertion);
   }
   diag(Loop->getForLoc(), "use range-based for loop instead") << FixIts;
   TUInfo->getGeneratedDecls().insert(make_pair(Loop, VarName));
 }
 
 /// Returns a string which refers to the container iterated over.
 StringRef LoopConvertCheck::getContainerString(ASTContext *Context,
                                                const ForStmt *Loop,
                                                const Expr *ContainerExpr) {
   StringRef ContainerString;
   ContainerExpr = ContainerExpr->IgnoreParenImpCasts();
   if (isa<CXXThisExpr>(ContainerExpr)) {
     ContainerString = "this";
   } else {
     // For CXXOperatorCallExpr such as vector_ptr->size() we want the class
     // object vector_ptr, but for vector[2] we need the whole expression.
     if (const auto* E = dyn_cast<CXXOperatorCallExpr>(ContainerExpr))
       if (E->getOperator() != OO_Subscript)
         ContainerExpr = E->getArg(0);
     ContainerString =
         getStringFromRange(Context->getSourceManager(), Context->getLangOpts(),
                            ContainerExpr->getSourceRange());
   }
 
   return ContainerString;
 }
 
 /// Determines what kind of 'auto' must be used after converting a for
 /// loop that iterates over an array or pseudoarray.
 void LoopConvertCheck::getArrayLoopQualifiers(ASTContext *Context,
                                               const BoundNodes &Nodes,
                                               const Expr *ContainerExpr,
                                               const UsageResult &Usages,
                                               RangeDescriptor &Descriptor) {
   // On arrays and pseudoarrays, we must figure out the qualifiers from the
   // usages.
   if (usagesAreConst(Context, Usages) ||
       containerIsConst(ContainerExpr, Descriptor.ContainerNeedsDereference)) {
     Descriptor.DerefByConstRef = true;
   }
   if (usagesReturnRValues(Usages)) {
     // If the index usages (dereference, subscript, at, ...) return rvalues,
     // then we should not use a reference, because we need to keep the code
     // correct if it mutates the returned objects.
     Descriptor.DerefByValue = true;
   }
   // Try to find the type of the elements on the container, to check if
   // they are trivially copyable.
   for (const Usage &U : Usages) {
     if (!U.Expression || U.Expression->getType().isNull())
       continue;
     QualType Type = U.Expression->getType().getCanonicalType();
     if (U.Kind == Usage::UK_MemberThroughArrow) {
       if (!Type->isPointerType()) {
         continue;
       }
       Type = Type->getPointeeType();
     }
     Descriptor.ElemType = Type;
   }
 }
 
 /// Determines what kind of 'auto' must be used after converting an
 /// iterator based for loop.
 void LoopConvertCheck::getIteratorLoopQualifiers(ASTContext *Context,
                                                  const BoundNodes &Nodes,
                                                  RangeDescriptor &Descriptor) {
   // The matchers for iterator loops provide bound nodes to obtain this
   // information.
   const auto *InitVar = Nodes.getNodeAs<VarDecl>(InitVarName);
   QualType CanonicalInitVarType = InitVar->getType().getCanonicalType();
   const auto *DerefByValueType =
       Nodes.getNodeAs<QualType>(DerefByValueResultName);
   Descriptor.DerefByValue = DerefByValueType;
 
   if (Descriptor.DerefByValue) {
     // If the dereference operator returns by value then test for the
     // canonical const qualification of the init variable type.
     Descriptor.DerefByConstRef = CanonicalInitVarType.isConstQualified();
     Descriptor.ElemType = *DerefByValueType;
   } else {
     if (const auto *DerefType =
             Nodes.getNodeAs<QualType>(DerefByRefResultName)) {
       // A node will only be bound with DerefByRefResultName if we're dealing
       // with a user-defined iterator type. Test the const qualification of
       // the reference type.
       auto ValueType = DerefType->getNonReferenceType();
 
       Descriptor.DerefByConstRef = ValueType.isConstQualified();
       Descriptor.ElemType = ValueType;
     } else {
       // By nature of the matcher this case is triggered only for built-in
       // iterator types (i.e. pointers).
       assert(isa<PointerType>(CanonicalInitVarType) &&
              "Non-class iterator type is not a pointer type");
 
       // We test for const qualification of the pointed-at type.
       Descriptor.DerefByConstRef =
           CanonicalInitVarType->getPointeeType().isConstQualified();
       Descriptor.ElemType = CanonicalInitVarType->getPointeeType();
     }
   }
 }
 
 /// Determines the parameters needed to build the range replacement.
 void LoopConvertCheck::determineRangeDescriptor(
     ASTContext *Context, const BoundNodes &Nodes, const ForStmt *Loop,
     LoopFixerKind FixerKind, const Expr *ContainerExpr,
     const UsageResult &Usages, RangeDescriptor &Descriptor) {
   Descriptor.ContainerString =
       std::string(getContainerString(Context, Loop, ContainerExpr));
   Descriptor.NeedsReverseCall = (FixerKind == LFK_ReverseIterator);
 
   if (FixerKind == LFK_Iterator || FixerKind == LFK_ReverseIterator)
     getIteratorLoopQualifiers(Context, Nodes, Descriptor);
   else
     getArrayLoopQualifiers(Context, Nodes, ContainerExpr, Usages, Descriptor);
 }
 
 /// Check some of the conditions that must be met for the loop to be
 /// convertible.
 bool LoopConvertCheck::isConvertible(ASTContext *Context,
                                      const ast_matchers::BoundNodes &Nodes,
                                      const ForStmt *Loop,
                                      LoopFixerKind FixerKind) {
   // In self contained diagnosics mode we don't want dependancies on other
   // loops, otherwise, If we already modified the range of this for loop, don't
   // do any further updates on this iteration.
   if (areDiagsSelfContained())
     TUInfo = std::make_unique<TUTrackingInfo>();
   else if (TUInfo->getReplacedVars().count(Loop))
     return false;
 
   // Check that we have exactly one index variable and at most one end variable.
   const auto *InitVar = Nodes.getNodeAs<VarDecl>(InitVarName);
 
   // FIXME: Try to put most of this logic inside a matcher.
   if (FixerKind == LFK_Iterator || FixerKind == LFK_ReverseIterator) {
     QualType InitVarType = InitVar->getType();
     QualType CanonicalInitVarType = InitVarType.getCanonicalType();
 
     const auto *BeginCall = Nodes.getNodeAs<CXXMemberCallExpr>(BeginCallName);
     assert(BeginCall && "Bad Callback. No begin call expression");
     QualType CanonicalBeginType =
         BeginCall->getMethodDecl()->getReturnType().getCanonicalType();
     if (CanonicalBeginType->isPointerType() &&
         CanonicalInitVarType->isPointerType()) {
       // If the initializer and the variable are both pointers check if the
       // un-qualified pointee types match, otherwise we don't use auto.
       if (!Context->hasSameUnqualifiedType(
               CanonicalBeginType->getPointeeType(),
               CanonicalInitVarType->getPointeeType()))
         return false;
     }
   } else if (FixerKind == LFK_PseudoArray) {
     // This call is required to obtain the container.
     const auto *EndCall = Nodes.getNodeAs<CXXMemberCallExpr>(EndCallName);
     if (!EndCall || !isa<MemberExpr>(EndCall->getCallee()))
       return false;
   }
   return true;
 }
 
 void LoopConvertCheck::check(const MatchFinder::MatchResult &Result) {
   const BoundNodes &Nodes = Result.Nodes;
   Confidence ConfidenceLevel(Confidence::CL_Safe);
   ASTContext *Context = Result.Context;
 
   const ForStmt *Loop;
   LoopFixerKind FixerKind;
   RangeDescriptor Descriptor;
 
   if ((Loop = Nodes.getNodeAs<ForStmt>(LoopNameArray))) {
     FixerKind = LFK_Array;
   } else if ((Loop = Nodes.getNodeAs<ForStmt>(LoopNameIterator))) {
     FixerKind = LFK_Iterator;
   } else if ((Loop = Nodes.getNodeAs<ForStmt>(LoopNameReverseIterator))) {
     FixerKind = LFK_ReverseIterator;
   } else {
     Loop = Nodes.getNodeAs<ForStmt>(LoopNamePseudoArray);
     assert(Loop && "Bad Callback. No for statement");
     FixerKind = LFK_PseudoArray;
   }
 
   if (!isConvertible(Context, Nodes, Loop, FixerKind))
     return;
 
   const auto *LoopVar = Nodes.getNodeAs<VarDecl>(InitVarName);
   const auto *EndVar = Nodes.getNodeAs<VarDecl>(EndVarName);
 
   // If the loop calls end()/size() after each iteration, lower our confidence
   // level.
   if (FixerKind != LFK_Array && !EndVar)
     ConfidenceLevel.lowerTo(Confidence::CL_Reasonable);
 
   // If the end comparison isn't a variable, we can try to work with the
   // expression the loop variable is being tested against instead.
   const auto *EndCall = Nodes.getNodeAs<CXXMemberCallExpr>(EndCallName);
   const auto *BoundExpr = Nodes.getNodeAs<Expr>(ConditionBoundName);
 
   // Find container expression of iterators and pseudoarrays, and determine if
   // this expression needs to be dereferenced to obtain the container.
   // With array loops, the container is often discovered during the
   // ForLoopIndexUseVisitor traversal.
   const Expr *ContainerExpr = nullptr;
   if (FixerKind == LFK_Iterator || FixerKind == LFK_ReverseIterator) {
     ContainerExpr = findContainer(
         Context, LoopVar->getInit(), EndVar ? EndVar->getInit() : EndCall,
         &Descriptor.ContainerNeedsDereference,
         /*IsReverse=*/FixerKind == LFK_ReverseIterator);
   } else if (FixerKind == LFK_PseudoArray) {
     ContainerExpr = EndCall->getImplicitObjectArgument();
     Descriptor.ContainerNeedsDereference =
         dyn_cast<MemberExpr>(EndCall->getCallee())->isArrow();
   }
 
   // We must know the container or an array length bound.
   if (!ContainerExpr && !BoundExpr)
     return;
 
   ForLoopIndexUseVisitor Finder(Context, LoopVar, EndVar, ContainerExpr,
                                 BoundExpr,
                                 Descriptor.ContainerNeedsDereference);
 
   // Find expressions and variables on which the container depends.
   if (ContainerExpr) {
     ComponentFinderASTVisitor ComponentFinder;
     ComponentFinder.findExprComponents(ContainerExpr->IgnoreParenImpCasts());
     Finder.addComponents(ComponentFinder.getComponents());
   }
 
   // Find usages of the loop index. If they are not used in a convertible way,
   // stop here.
   if (!Finder.findAndVerifyUsages(Loop->getBody()))
     return;
   ConfidenceLevel.lowerTo(Finder.getConfidenceLevel());
 
   // Obtain the container expression, if we don't have it yet.
   if (FixerKind == LFK_Array) {
     ContainerExpr = Finder.getContainerIndexed()->IgnoreParenImpCasts();
 
     // Very few loops are over expressions that generate arrays rather than
     // array variables. Consider loops over arrays that aren't just represented
     // by a variable to be risky conversions.
     if (!getReferencedVariable(ContainerExpr) &&
         !isDirectMemberExpr(ContainerExpr))
       ConfidenceLevel.lowerTo(Confidence::CL_Risky);
   }
 
   // Find out which qualifiers we have to use in the loop range.
   TraversalKindScope RAII(*Context, TK_AsIs);
   const UsageResult &Usages = Finder.getUsages();
   determineRangeDescriptor(Context, Nodes, Loop, FixerKind, ContainerExpr,
                            Usages, Descriptor);
 
   // Ensure that we do not try to move an expression dependent on a local
   // variable declared inside the loop outside of it.
   // FIXME: Determine when the external dependency isn't an expression converted
   // by another loop.
   TUInfo->getParentFinder().gatherAncestors(*Context);
   DependencyFinderASTVisitor DependencyFinder(
       &TUInfo->getParentFinder().getStmtToParentStmtMap(),
       &TUInfo->getParentFinder().getDeclToParentStmtMap(),
       &TUInfo->getReplacedVars(), Loop);
 
   if (DependencyFinder.dependsOnInsideVariable(ContainerExpr) ||
       Descriptor.ContainerString.empty() || Usages.empty() ||
       ConfidenceLevel.getLevel() < MinConfidence)
     return;
 
   doConversion(Context, LoopVar, getReferencedVariable(ContainerExpr), Usages,
                Finder.getAliasDecl(), Finder.aliasUseRequired(),
                Finder.aliasFromForInit(), Loop, Descriptor);
 }
 
 llvm::StringRef LoopConvertCheck::getReverseFunction() const {
   if (!ReverseFunction.empty())
     return ReverseFunction;
   if (UseReverseRanges)
     return "std::ranges::reverse_view";
   return "";
 }
 
 llvm::StringRef LoopConvertCheck::getReverseHeader() const {
   if (!ReverseHeader.empty())
     return ReverseHeader;
   if (UseReverseRanges && ReverseFunction.empty()) {
     return "<ranges>";
   }
   return "";
 }
 
 } // namespace modernize
 } // namespace tidy
 } // namespace clang
diff --git a/clang-tools-extra/docs/ReleaseNotes.rst b/clang-tools-extra/docs/ReleaseNotes.rst
index 2135dd1e01be..0e81a630b3ce 100644
--- a/clang-tools-extra/docs/ReleaseNotes.rst
+++ b/clang-tools-extra/docs/ReleaseNotes.rst
@@ -1,229 +1,233 @@
 ====================================================
 Extra Clang Tools |release| |ReleaseNotesTitle|
 ====================================================
 
 .. contents::
    :local:
    :depth: 3
 
 Written by the `LLVM Team <https://llvm.org/>`_
 
 .. only:: PreRelease
 
   .. warning::
      These are in-progress notes for the upcoming Extra Clang Tools |version| release.
      Release notes for previous releases can be found on
      `the Download Page <https://releases.llvm.org/download.html>`_.
 
 Introduction
 ============
 
 This document contains the release notes for the Extra Clang Tools, part of the
 Clang release |release|. Here we describe the status of the Extra Clang Tools in
 some detail, including major improvements from the previous release and new
 feature work. All LLVM releases may be downloaded from the `LLVM releases web
 site <https://llvm.org/releases/>`_.
 
 For more information about Clang or LLVM, including information about
 the latest release, please see the `Clang Web Site <https://clang.llvm.org>`_ or
 the `LLVM Web Site <https://llvm.org>`_.
 
 Note that if you are reading this file from a Git checkout or the
 main Clang web page, this document applies to the *next* release, not
 the current one. To see the release notes for a specific release, please
 see the `releases page <https://llvm.org/releases/>`_.
 
 What's New in Extra Clang Tools |release|?
 ==========================================
 
 Some of the major new features and improvements to Extra Clang Tools are listed
 here. Generic improvements to Extra Clang Tools as a whole or to its underlying
 infrastructure are described first, followed by tool-specific sections.
 
 Major New Features
 ------------------
 
 ...
 
 Improvements to clangd
 ----------------------
 
 Inlay hints
 ^^^^^^^^^^^
 
 Diagnostics
 ^^^^^^^^^^^
 
 Semantic Highlighting
 ^^^^^^^^^^^^^^^^^^^^^
 
 Compile flags
 ^^^^^^^^^^^^^
 
 Hover
 ^^^^^
 
 Code completion
 ^^^^^^^^^^^^^^^
 
 Signature help
 ^^^^^^^^^^^^^^
 
 Cross-references
 ^^^^^^^^^^^^^^^^
 
 Objective-C
 ^^^^^^^^^^^
 
 Miscellaneous
 ^^^^^^^^^^^^^
 
 Improvements to clang-doc
 -------------------------
 
 - The default executor was changed to standalone to match other tools.
 
 Improvements to clang-query
 ---------------------------
 
 The improvements are...
 
 Improvements to clang-rename
 ----------------------------
 
 The improvements are...
 
 Improvements to clang-tidy
 --------------------------
 
 - Change to Python 3 in the shebang of `add_new_check.py` and `rename_check.py`,
   as the existing code is not compatible with Python 2.
 
 New checks
 ^^^^^^^^^^
 
 - New :doc:`bugprone-suspicious-realloc-usage
   <clang-tidy/checks/bugprone/suspicious-realloc-usage>` check.
 
   Finds usages of ``realloc`` where the return value is assigned to the
   same expression as passed to the first argument.
 
 - New :doc:`cppcoreguidelines-avoid-const-or-ref-data-members
   <clang-tidy/checks/cppcoreguidelines/avoid-const-or-ref-data-members>` check.
 
   Warns when a struct or class uses const or reference (lvalue or rvalue) data members.
 
 - New :doc:`cppcoreguidelines-avoid-do-while
   <clang-tidy/checks/cppcoreguidelines/avoid-do-while>` check.
 
   Warns when using ``do-while`` loops.
 
 - New :doc:`misc-use-anonymous-namespace
   <clang-tidy/checks/misc/use-anonymous-namespace>` check.
 
   Warns when using ``static`` function or variables at global scope, and suggests
   moving them into an anonymous namespace.
 
 - New :doc:`bugprone-standalone-empty <clang-tidy/checks/bugprone/standalone-empty>` check.
 
   Warns when `empty()` is used on a range and the result is ignored. Suggests `clear()`
   if it is an existing member function.
 
 New check aliases
 ^^^^^^^^^^^^^^^^^
 
 - New alias :doc:`cert-msc54-cpp
   <clang-tidy/checks/cert/msc54-cpp>` to
   :doc:`bugprone-signal-handler
   <clang-tidy/checks/bugprone/signal-handler>` was added.
 
 
 Changes in existing checks
 ^^^^^^^^^^^^^^^^^^^^^^^^^^
 
 - Fixed a false positive in :doc:`bugprone-assignment-in-if-condition
   <clang-tidy/checks/bugprone/assignment-in-if-condition>` check when there
   was an assignement in a lambda found in the condition of an ``if``.
 
 - Improved :doc:`bugprone-signal-handler
   <clang-tidy/checks/bugprone/signal-handler>` check. Partial
   support for C++14 signal handler rules was added. Bug report generation was
   improved.
 
 - Fixed a false positive in :doc:`cppcoreguidelines-pro-type-member-init
   <clang-tidy/checks/cppcoreguidelines/pro-type-member-init>` when warnings
   would be emitted for uninitialized members of an anonymous union despite
   there being an initializer for one of the other members.
 
 - Fixed false positives in :doc:`google-objc-avoid-throwing-exception
   <clang-tidy/checks/google/objc-avoid-throwing-exception>` check for exceptions
   thrown by code emitted from macros in system headers.
 
 - Improved :doc:`modernize-use-emplace <clang-tidy/checks/modernize/use-emplace>`
   check.
 
   The check now supports detecting inefficient invocations of ``push`` and
   ``push_front`` on STL-style containers and replacing them with ``emplace``
   or ``emplace_front``.
 
   The check now supports detecting alias cases of ``push_back`` ``push`` and
   ``push_front`` on STL-style containers and replacing them with ``emplace_back``,
   ``emplace`` or ``emplace_front``.
 
 - Improved :doc:`modernize-use-equals-default <clang-tidy/checks/modernize/use-equals-default>`
   check.
 
   The check now skips unions/union-like classes since in this case a default constructor
   with empty body is not equivalent to the explicitly defaulted one, variadic constructors
   since they cannot be explicitly defaulted. The check also skips copy assignment operators
   with nonstandard return types, template constructors, private/protected default constructors
   for C++17 or earlier. The automatic fixit has been adjusted to avoid adding superfluous
   semicolon. The check is restricted to C++11 or later.
 
 - Change the default behavior of :doc:`readability-avoid-const-params-in-decls
   <clang-tidy/checks/readability/avoid-const-params-in-decls>` to not
   warn about `const` value parameters of declarations inside macros.
 
 - Fixed crashes in :doc:`readability-braces-around-statements
   <clang-tidy/checks/readability/braces-around-statements>` and
   :doc:`readability-simplify-boolean-expr <clang-tidy/checks/readability/simplify-boolean-expr>`
   when using a C++23 ``if consteval`` statement.
 
 - Change the behavior of :doc:`readability-const-return-type
   <clang-tidy/checks/readability/const-return-type>` to not
   warn about `const` return types in overridden functions since the derived
   class cannot always choose to change the function signature.
 
 - Change the default behavior of :doc:`readability-const-return-type
   <clang-tidy/checks/readability/const-return-type>` to not
   warn about `const` value parameters of declarations inside macros.
 
 - Improved :doc:`misc-redundant-expression <clang-tidy/checks/misc/redundant-expression>`
   check.
 
   The check now skips concept definitions since redundant expressions still make sense
   inside them.
 
+- Improved :doc:`misc-redundant-expression <clang-tidy/checks/modernize/loop-convert>`
+  to check for container functions ``begin``/``end`` etc on base classes of the container
+  type, instead of only as direct members of the container type itself.
+
 Removed checks
 ^^^^^^^^^^^^^^
 
 Improvements to include-fixer
 -----------------------------
 
 The improvements are...
 
 Improvements to clang-include-fixer
 -----------------------------------
 
 The improvements are...
 
 Improvements to modularize
 --------------------------
 
 The improvements are...
 
 Improvements to pp-trace
 ------------------------
 
 Clang-tidy Visual Studio plugin
 -------------------------------
diff --git a/clang-tools-extra/test/clang-tidy/checkers/modernize/Inputs/loop-convert/structures.h b/clang-tools-extra/test/clang-tidy/checkers/modernize/Inputs/loop-convert/structures.h
index abd64904ee70..bc025ceab1f7 100644
--- a/clang-tools-extra/test/clang-tidy/checkers/modernize/Inputs/loop-convert/structures.h
+++ b/clang-tools-extra/test/clang-tidy/checkers/modernize/Inputs/loop-convert/structures.h
@@ -1,224 +1,228 @@
 #ifndef STRUCTURES_H
 #define STRUCTURES_H
 
 extern "C" {
 extern int printf(const char *restrict, ...);
 }
 
 struct Val {int X; void g(); };
 
 struct MutableVal {
   void constFun(int) const;
   void nonConstFun(int, int);
   void constFun(MutableVal &) const;
   void constParamFun(const MutableVal &) const;
   void nonConstParamFun(const MutableVal &);
   int X;
 };
 
 struct NonTriviallyCopyable {
   NonTriviallyCopyable() = default;
   // Define this constructor to make this class non-trivially copyable.
   NonTriviallyCopyable(const NonTriviallyCopyable& Ntc);
   int X;
 };
 
 struct TriviallyCopyableButBig {
   int X;
   char Array[16];
 };
 
 struct S {
   typedef MutableVal *iterator;
   typedef const MutableVal *const_iterator;
   const_iterator begin() const;
   const_iterator end() const;
   const_iterator cbegin() const;
   const_iterator cend() const;
   iterator begin();
   iterator end();
 };
 
 struct T {
   typedef int value_type;
   struct iterator {
     value_type &operator*();
     const value_type &operator*() const;
     iterator& operator ++();
     bool operator!=(const iterator &other);
     void insert(value_type);
     value_type X;
   };
   iterator begin();
   iterator end();
 };
 
 struct Q {
   typedef int value_type;
   struct const_iterator {
     value_type &operator*();
     const value_type &operator*() const;
     const_iterator &operator++();
     bool operator!=(const const_iterator &other);
     void insert(value_type);
     value_type X;
   };
   struct iterator {
     operator const_iterator() const;
   };
   iterator begin();
   iterator end();
 };
 
 struct U {
   struct iterator {
     Val& operator*();
     const Val& operator*()const;
     iterator& operator ++();
     bool operator!=(const iterator &other);
     Val *operator->();
   };
   iterator begin();
   iterator end();
   int X;
 };
 
 struct X {
   S Ss;
   T Tt;
   U Uu;
   S getS();
 };
 
 template<typename ElemType>
 class dependent {
  public:
   dependent<ElemType>();
   struct iterator_base {
     const ElemType& operator*()const;
     iterator_base& operator ++();
     bool operator!=(const iterator_base &other) const;
     const ElemType *operator->() const;
   };
 
   struct iterator : iterator_base {
     ElemType& operator*();
     iterator& operator ++();
     ElemType *operator->();
   };
 
   typedef iterator_base const_iterator;
   const_iterator begin() const;
   const_iterator end() const;
   iterator begin();
   iterator end();
   unsigned size() const;
   ElemType & operator[](unsigned);
   const ElemType & operator[](unsigned) const;
   ElemType & at(unsigned);
   ElemType & at(unsigned, unsigned);
   const ElemType & at(unsigned) const;
 
   // Intentionally evil.
   dependent<ElemType> operator*();
 
   void foo();
   void constFoo() const;
 };
 
+template<typename ElemType>
+class dependent_derived : public dependent<ElemType> {
+};
+
 template<typename First, typename Second>
 class doublyDependent{
  public:
   struct Value {
     First first;
     Second second;
   };
 
   struct iterator_base {
     const Value& operator*()const;
     iterator_base& operator ++();
     bool operator!=(const iterator_base &other) const;
     const Value *operator->() const;
   };
 
   struct iterator : iterator_base {
     Value& operator*();
     Value& operator ++();
     Value *operator->();
   };
 
   typedef iterator_base const_iterator;
   const_iterator begin() const;
   const_iterator end() const;
   iterator begin();
   iterator end();
 };
 
 template<typename Contained>
 class transparent {
  public:
   Contained *at();
   Contained *operator->();
   Contained operator*();
 };
 
 template<typename IteratorType>
 struct Nested {
   typedef IteratorType* iterator;
   typedef const IteratorType* const_iterator;
   IteratorType *operator->();
   IteratorType operator*();
   iterator begin();
   iterator end();
   const_iterator begin() const;
   const_iterator end() const;
 };
 
 // Like llvm::SmallPtrSet, the iterator has a dereference operator that returns
 // by value instead of by reference.
 template <typename T>
 struct PtrSet {
   struct iterator {
     bool operator!=(const iterator &other) const;
     const T operator*();
     iterator &operator++();
   };
   iterator begin() const;
   iterator end() const;
 };
 
 template <typename T>
 struct TypedefDerefContainer {
   struct iterator {
     typedef T &deref_type;
     bool operator!=(const iterator &other) const;
     deref_type operator*();
     iterator &operator++();
   };
   iterator begin() const;
   iterator end() const;
 };
 
 template <typename T>
 struct RValueDerefContainer {
   struct iterator {
     typedef T &&deref_type;
     bool operator!=(const iterator &other) const;
     deref_type operator*();
     iterator &operator++();
   };
   iterator begin() const;
   iterator end() const;
 };
 
 namespace Macros {
 
 struct MacroStruct {
   int Arr[10];
 };
 static MacroStruct *MacroSt;
 #define CONT MacroSt->
 
 } // namespace Macros
 
 #endif  // STRUCTURES_H
diff --git a/clang-tools-extra/test/clang-tidy/checkers/modernize/loop-convert-basic.cpp b/clang-tools-extra/test/clang-tidy/checkers/modernize/loop-convert-basic.cpp
index b42ce4a19a6b..96b395635878 100644
--- a/clang-tools-extra/test/clang-tidy/checkers/modernize/loop-convert-basic.cpp
+++ b/clang-tools-extra/test/clang-tidy/checkers/modernize/loop-convert-basic.cpp
@@ -1,860 +1,870 @@
 // RUN: %check_clang_tidy %s modernize-loop-convert %t -- -- -I %S/Inputs/loop-convert
 
 #include "structures.h"
 
 namespace Array {
 
 const int N = 6;
 const int NMinusOne = N - 1;
 int Arr[N] = {1, 2, 3, 4, 5, 6};
 const int ConstArr[N] = {1, 2, 3, 4, 5, 6};
 int (*PArr)[N] = &Arr;
 
 void f() {
   int Sum = 0;
 
   for (int I = 0; I < N; ++I) {
     Sum += Arr[I];
     int K;
   }
   // CHECK-MESSAGES: :[[@LINE-4]]:3: warning: use range-based for loop instead [modernize-loop-convert]
   // CHECK-FIXES: for (int I : Arr)
   // CHECK-FIXES-NEXT: Sum += I;
   // CHECK-FIXES-NEXT: int K;
 
   for (int I = 0; I < N; ++I) {
     printf("Fibonacci number is %d\n", Arr[I]);
     Sum += Arr[I] + 2;
   }
   // CHECK-MESSAGES: :[[@LINE-4]]:3: warning: use range-based for loop instead
   // CHECK-FIXES: for (int I : Arr)
   // CHECK-FIXES-NEXT: printf("Fibonacci number is %d\n", I);
   // CHECK-FIXES-NEXT: Sum += I + 2;
 
   for (int I = 0; I < N; ++I) {
     int X = Arr[I];
     int Y = Arr[I] + 2;
   }
   // CHECK-MESSAGES: :[[@LINE-4]]:3: warning: use range-based for loop instead
   // CHECK-FIXES: for (int I : Arr)
   // CHECK-FIXES-NEXT: int X = I;
   // CHECK-FIXES-NEXT: int Y = I + 2;
 
   for (int I = 0; I < N; ++I) {
     int X = N;
     X = Arr[I];
   }
   // CHECK-MESSAGES: :[[@LINE-4]]:3: warning: use range-based for loop instead
   // CHECK-FIXES: for (int I : Arr)
   // CHECK-FIXES-NEXT: int X = N;
   // CHECK-FIXES-NEXT: X = I;
 
   for (int I = 0; I < N; ++I) {
     Arr[I] += 1;
   }
   // CHECK-MESSAGES: :[[@LINE-3]]:3: warning: use range-based for loop instead
   // CHECK-FIXES: for (int & I : Arr)
   // CHECK-FIXES-NEXT: I += 1;
 
   for (int I = 0; I < N; ++I) {
     int X = Arr[I] + 2;
     Arr[I]++;
   }
   // CHECK-MESSAGES: :[[@LINE-4]]:3: warning: use range-based for loop instead
   // CHECK-FIXES: for (int & I : Arr)
   // CHECK-FIXES-NEXT: int X = I + 2;
   // CHECK-FIXES-NEXT: I++;
 
   for (int I = 0; I < N; ++I) {
     Arr[I] = 4 + Arr[I];
   }
   // CHECK-MESSAGES: :[[@LINE-3]]:3: warning: use range-based for loop instead
   // CHECK-FIXES: for (int & I : Arr)
   // CHECK-FIXES-NEXT: I = 4 + I;
 
   for (int I = 0; I < NMinusOne + 1; ++I) {
     Sum += Arr[I];
   }
   // CHECK-MESSAGES: :[[@LINE-3]]:3: warning: use range-based for loop instead
   // CHECK-FIXES: for (int I : Arr)
   // CHECK-FIXES-NEXT: Sum += I;
 
   for (int I = 0; I < N; ++I) {
     printf("Fibonacci number %d has address %p\n", Arr[I], &Arr[I]);
     Sum += Arr[I] + 2;
   }
   // CHECK-MESSAGES: :[[@LINE-4]]:3: warning: use range-based for loop instead
   // CHECK-FIXES: for (int & I : Arr)
   // CHECK-FIXES-NEXT: printf("Fibonacci number %d has address %p\n", I, &I);
   // CHECK-FIXES-NEXT: Sum += I + 2;
 
   Val Teas[N];
   for (int I = 0; I < N; ++I) {
     Teas[I].g();
   }
   // CHECK-MESSAGES: :[[@LINE-3]]:3: warning: use range-based for loop instead
   // CHECK-FIXES: for (auto & Tea : Teas)
   // CHECK-FIXES-NEXT: Tea.g();
 
   for (int I = 0; N > I; ++I) {
     printf("Fibonacci number %d has address %p\n", Arr[I], &Arr[I]);
     Sum += Arr[I] + 2;
   }
   // CHECK-MESSAGES: :[[@LINE-4]]:3: warning: use range-based for loop instead
   // CHECK-FIXES: for (int & I : Arr)
   // CHECK-FIXES-NEXT: printf("Fibonacci number %d has address %p\n", I, &I);
   // CHECK-FIXES-NEXT: Sum += I + 2;
 
   for (int I = 0; N != I; ++I) {
     printf("Fibonacci number %d has address %p\n", Arr[I], &Arr[I]);
     Sum += Arr[I] + 2;
   }
   // CHECK-MESSAGES: :[[@LINE-4]]:3: warning: use range-based for loop instead
   // CHECK-FIXES: for (int & I : Arr)
   // CHECK-FIXES-NEXT: printf("Fibonacci number %d has address %p\n", I, &I);
   // CHECK-FIXES-NEXT: Sum += I + 2;
 
   for (int I = 0; I != N; ++I) {
     printf("Fibonacci number %d has address %p\n", Arr[I], &Arr[I]);
     Sum += Arr[I] + 2;
   }
   // CHECK-MESSAGES: :[[@LINE-4]]:3: warning: use range-based for loop instead
   // CHECK-FIXES: for (int & I : Arr)
   // CHECK-FIXES-NEXT: printf("Fibonacci number %d has address %p\n", I, &I);
   // CHECK-FIXES-NEXT: Sum += I + 2;
 }
 
 const int *constArray() {
   for (int I = 0; I < N; ++I) {
     printf("2 * %d = %d\n", ConstArr[I], ConstArr[I] + ConstArr[I]);
   }
   // CHECK-MESSAGES: :[[@LINE-3]]:3: warning: use range-based for loop instead
   // CHECK-FIXES: for (int I : ConstArr)
   // CHECK-FIXES-NEXT: printf("2 * %d = %d\n", I, I + I);
 
   const NonTriviallyCopyable NonCopy[N]{};
   for (int I = 0; I < N; ++I) {
     printf("2 * %d = %d\n", NonCopy[I].X, NonCopy[I].X + NonCopy[I].X);
   }
   // CHECK-MESSAGES: :[[@LINE-3]]:3: warning: use range-based for loop instead
   // CHECK-FIXES: for (const auto & I : NonCopy)
   // CHECK-FIXES-NEXT: printf("2 * %d = %d\n", I.X, I.X + I.X);
 
   const TriviallyCopyableButBig Big[N]{};
   for (int I = 0; I < N; ++I) {
     printf("2 * %d = %d\n", Big[I].X, Big[I].X + Big[I].X);
   }
   // CHECK-MESSAGES: :[[@LINE-3]]:3: warning: use range-based for loop instead
   // CHECK-FIXES: for (const auto & I : Big)
   // CHECK-FIXES-NEXT: printf("2 * %d = %d\n", I.X, I.X + I.X);
 
   bool Something = false;
   for (int I = 0; I < N; ++I) {
     if (Something)
       return &ConstArr[I];
   }
   // CHECK-MESSAGES: :[[@LINE-4]]:3: warning: use range-based for loop instead
   // CHECK-FIXES: for (const int & I : ConstArr)
   // CHECK-FIXES-NEXT: if (Something)
   // CHECK-FIXES-NEXT: return &I;
 }
 
 struct HasArr {
   int Arr[N];
   Val ValArr[N];
   void implicitThis() {
     for (int I = 0; I < N; ++I) {
       printf("%d", Arr[I]);
     }
     // CHECK-MESSAGES: :[[@LINE-3]]:5: warning: use range-based for loop instead
     // CHECK-FIXES: for (int I : Arr)
     // CHECK-FIXES-NEXT: printf("%d", I);
 
     for (int I = 0; I < N; ++I) {
       printf("%d", ValArr[I].X);
     }
     // CHECK-MESSAGES: :[[@LINE-3]]:5: warning: use range-based for loop instead
     // CHECK-FIXES: for (auto & I : ValArr)
     // CHECK-FIXES-NEXT: printf("%d", I.X);
   }
 
   void explicitThis() {
     for (int I = 0; I < N; ++I) {
       printf("%d", this->Arr[I]);
     }
     // CHECK-MESSAGES: :[[@LINE-3]]:5: warning: use range-based for loop instead
     // CHECK-FIXES: for (int I : this->Arr)
     // CHECK-FIXES-NEXT: printf("%d", I);
 
     for (int I = 0; I < N; ++I) {
       printf("%d", this->ValArr[I].X);
     }
     // CHECK-MESSAGES: :[[@LINE-3]]:5: warning: use range-based for loop instead
     // CHECK-FIXES: for (auto & I : this->ValArr)
     // CHECK-FIXES-NEXT: printf("%d", I.X);
   }
 };
 
 struct HasIndirectArr {
   HasArr HA;
   void implicitThis() {
     for (int I = 0; I < N; ++I) {
       printf("%d", HA.Arr[I]);
     }
     // CHECK-MESSAGES: :[[@LINE-3]]:5: warning: use range-based for loop instead
     // CHECK-FIXES: for (int I : HA.Arr)
     // CHECK-FIXES-NEXT: printf("%d", I);
 
     for (int I = 0; I < N; ++I) {
       printf("%d", HA.ValArr[I].X);
     }
     // CHECK-MESSAGES: :[[@LINE-3]]:5: warning: use range-based for loop instead
     // CHECK-FIXES: for (auto & I : HA.ValArr)
     // CHECK-FIXES-NEXT: printf("%d", I.X);
   }
 
   void explicitThis() {
     for (int I = 0; I < N; ++I) {
       printf("%d", this->HA.Arr[I]);
     }
     // CHECK-MESSAGES: :[[@LINE-3]]:5: warning: use range-based for loop instead
     // CHECK-FIXES: for (int I : this->HA.Arr)
     // CHECK-FIXES-NEXT: printf("%d", I);
 
     for (int I = 0; I < N; ++I) {
       printf("%d", this->HA.ValArr[I].X);
     }
     // CHECK-MESSAGES: :[[@LINE-3]]:5: warning: use range-based for loop instead
     // CHECK-FIXES: for (auto & I : this->HA.ValArr)
     // CHECK-FIXES-NEXT: printf("%d", I.X);
   }
 };
 
 // Loops whose bounds are value-dependent should not be converted.
 template <int N>
 void dependentExprBound() {
   for (int I = 0; I < N; ++I)
     Arr[I] = 0;
 }
 template void dependentExprBound<20>();
 
 void memberFunctionPointer() {
   Val V;
   void (Val::*mfpArr[N])(void) = {&Val::g};
   for (int I = 0; I < N; ++I)
     (V.*mfpArr[I])();
   // CHECK-MESSAGES: :[[@LINE-2]]:3: warning: use range-based for loop instead
   // CHECK-FIXES: for (auto & I : mfpArr)
   // CHECK-FIXES-NEXT: (V.*I)();
 
   struct Foo {
     int (Val::*f)();
   } Foo[N];
 
   for (int I = 0; I < N; ++I)
     int R = (V.*(Foo[I].f))();
   // CHECK-MESSAGES: :[[@LINE-2]]:3: warning: use range-based for loop instead
   // CHECK-FIXES: for (auto & I : Foo)
   // CHECK-FIXES-NEXT: int R = (V.*(I.f))();
 
 }
 
 } // namespace Array
 
 namespace Iterator {
 
 void f() {
   /// begin()/end() - based for loops here:
   T Tt;
   for (T::iterator It = Tt.begin(), E = Tt.end(); It != E; ++It) {
     printf("I found %d\n", *It);
   }
   // CHECK-MESSAGES: :[[@LINE-3]]:3: warning: use range-based for loop instead
   // CHECK-FIXES: for (int & It : Tt)
   // CHECK-FIXES-NEXT: printf("I found %d\n", It);
 
   // Do not crash because of Qq.begin() converting. Q::iterator converts with a
   // conversion operator, which has no name, to Q::const_iterator.
   Q Qq;
   for (Q::const_iterator It = Qq.begin(), E = Qq.end(); It != E; ++It) {
     printf("I found %d\n", *It);
   }
   // CHECK-MESSAGES: :[[@LINE-3]]:3: warning: use range-based for loop instead
   // CHECK-FIXES: for (int & It : Qq)
   // CHECK-FIXES-NEXT: printf("I found %d\n", It);
 
   T *Pt;
   for (T::iterator It = Pt->begin(), E = Pt->end(); It != E; ++It) {
     printf("I found %d\n", *It);
   }
   // CHECK-MESSAGES: :[[@LINE-3]]:3: warning: use range-based for loop instead
   // CHECK-FIXES: for (int & It : *Pt)
   // CHECK-FIXES-NEXT: printf("I found %d\n", It);
 
   S Ss;
   for (S::iterator It = Ss.begin(), E = Ss.end(); It != E; ++It) {
     printf("s has value %d\n", (*It).X);
   }
   // CHECK-MESSAGES: :[[@LINE-3]]:3: warning: use range-based for loop instead
   // CHECK-FIXES: for (auto & It : Ss)
   // CHECK-FIXES-NEXT: printf("s has value %d\n", It.X);
 
   S *Ps;
   for (S::iterator It = Ps->begin(), E = Ps->end(); It != E; ++It) {
     printf("s has value %d\n", (*It).X);
   }
   // CHECK-MESSAGES: :[[@LINE-3]]:3: warning: use range-based for loop instead
   // CHECK-FIXES: for (auto & P : *Ps)
   // CHECK-FIXES-NEXT: printf("s has value %d\n", P.X);
 
   for (S::const_iterator It = Ss.cbegin(), E = Ss.cend(); It != E; ++It) {
     printf("s has value %d\n", (*It).X);
   }
   // CHECK-MESSAGES: :[[@LINE-3]]:3: warning: use range-based for loop instead
   // CHECK-FIXES: for (auto It : Ss)
   // CHECK-FIXES-NEXT: printf("s has value %d\n", It.X);
 
   for (S::iterator It = Ss.begin(), E = Ss.end(); It != E; ++It) {
     printf("s has value %d\n", It->X);
   }
   // CHECK-MESSAGES: :[[@LINE-3]]:3: warning: use range-based for loop instead
   // CHECK-FIXES: for (auto & It : Ss)
   // CHECK-FIXES-NEXT: printf("s has value %d\n", It.X);
 
   for (S::iterator It = Ss.begin(), E = Ss.end(); It != E; ++It) {
     It->X = 3;
   }
   // CHECK-MESSAGES: :[[@LINE-3]]:3: warning: use range-based for loop instead
   // CHECK-FIXES: for (auto & It : Ss)
   // CHECK-FIXES-NEXT: It.X = 3;
 
   for (S::iterator It = Ss.begin(), E = Ss.end(); It != E; ++It) {
     (*It).X = 3;
   }
   // CHECK-MESSAGES: :[[@LINE-3]]:3: warning: use range-based for loop instead
   // CHECK-FIXES: for (auto & It : Ss)
   // CHECK-FIXES-NEXT: It.X = 3;
 
   for (S::iterator It = Ss.begin(), E = Ss.end(); It != E; ++It) {
     It->nonConstFun(4, 5);
   }
   // CHECK-MESSAGES: :[[@LINE-3]]:3: warning: use range-based for loop instead
   // CHECK-FIXES: for (auto & It : Ss)
   // CHECK-FIXES-NEXT: It.nonConstFun(4, 5);
 
   U Uu;
   for (U::iterator It = Uu.begin(), E = Uu.end(); It != E; ++It) {
     printf("s has value %d\n", It->X);
   }
   // CHECK-MESSAGES: :[[@LINE-3]]:3: warning: use range-based for loop instead
   // CHECK-FIXES: for (auto & It : Uu)
   // CHECK-FIXES-NEXT: printf("s has value %d\n", It.X);
 
   for (U::iterator It = Uu.begin(), E = Uu.end(); It != E; ++It) {
     printf("s has value %d\n", (*It).X);
   }
   // CHECK-MESSAGES: :[[@LINE-3]]:3: warning: use range-based for loop instead
   // CHECK-FIXES: for (auto & It : Uu)
   // CHECK-FIXES-NEXT: printf("s has value %d\n", It.X);
 
   for (U::iterator It = Uu.begin(), E = Uu.end(); It != E; ++It) {
     Val* a = It.operator->();
   }
 
   U::iterator A;
   for (U::iterator I = Uu.begin(), E = Uu.end(); I != E; ++I)
     int K = A->X + I->X;
   // CHECK-MESSAGES: :[[@LINE-2]]:3: warning: use range-based for loop instead
   // CHECK-FIXES: for (auto & I : Uu)
   // CHECK-FIXES-NEXT: int K = A->X + I.X;
 
   dependent<int> V;
   for (dependent<int>::iterator It = V.begin(), E = V.end();
        It != E; ++It) {
     printf("Fibonacci number is %d\n", *It);
   }
   // CHECK-MESSAGES: :[[@LINE-4]]:3: warning: use range-based for loop instead
   // CHECK-FIXES: for (int & It : V)
   // CHECK-FIXES-NEXT: printf("Fibonacci number is %d\n", It);
 
   for (dependent<int>::iterator It(V.begin()), E = V.end();
        It != E; ++It) {
     printf("Fibonacci number is %d\n", *It);
   }
   // CHECK-MESSAGES: :[[@LINE-4]]:3: warning: use range-based for loop instead
   // CHECK-FIXES: for (int & It : V)
   // CHECK-FIXES-NEXT: printf("Fibonacci number is %d\n", It);
 
   doublyDependent<int, int> Intmap;
   for (doublyDependent<int, int>::iterator It = Intmap.begin(), E = Intmap.end();
        It != E; ++It) {
     printf("Intmap[%d] = %d", It->first, It->second);
   }
   // CHECK-MESSAGES: :[[@LINE-4]]:3: warning: use range-based for loop instead
   // CHECK-FIXES: for (auto & It : Intmap)
   // CHECK-FIXES: printf("Intmap[%d] = %d", It.first, It.second);
 
   // PtrSet's iterator dereferences by value so auto & can't be used.
   {
     PtrSet<int *> Val_int_ptrs;
     for (PtrSet<int *>::iterator I = Val_int_ptrs.begin(),
                                  E = Val_int_ptrs.end();
          I != E; ++I) {
       (void) *I;
     }
     // CHECK-MESSAGES: :[[@LINE-5]]:5: warning: use range-based for loop instead
     // CHECK-FIXES: for (auto Val_int_ptr : Val_int_ptrs)
   }
 
   // This container uses an iterator where the dereference type is a typedef of
   // a reference type. Make sure non-const auto & is still used. A failure here
   // means canonical types aren't being tested.
   {
     TypedefDerefContainer<int> Int_ptrs;
     for (TypedefDerefContainer<int>::iterator I = Int_ptrs.begin(),
                                               E = Int_ptrs.end();
          I != E; ++I) {
       (void) *I;
     }
     // CHECK-MESSAGES: :[[@LINE-5]]:5: warning: use range-based for loop instead
     // CHECK-FIXES: for (int & Int_ptr : Int_ptrs)
   }
 
   {
     // Iterators returning an rvalue reference should disqualify the loop from
     // transformation.
     RValueDerefContainer<int> Container;
     for (RValueDerefContainer<int>::iterator I = Container.begin(),
                                              E = Container.end();
          I != E; ++I) {
       (void) *I;
     }
   }
 
   dependent<Val *> Dpp;
   for (dependent<Val *>::iterator I = Dpp.begin(), E = Dpp.end(); I != E; ++I) {
     printf("%d\n", (**I).X);
   }
   // CHECK-MESSAGES: :[[@LINE-3]]:3: warning: use range-based for loop instead
   // CHECK-FIXES: for (auto & I : Dpp)
   // CHECK-FIXES-NEXT: printf("%d\n", (*I).X);
 
   for (dependent<Val *>::iterator I = Dpp.begin(), E = Dpp.end(); I != E; ++I) {
     printf("%d\n", (*I)->X);
   }
   // CHECK-MESSAGES: :[[@LINE-3]]:3: warning: use range-based for loop instead
   // CHECK-FIXES: for (auto & I : Dpp)
   // CHECK-FIXES-NEXT: printf("%d\n", I->X);
 }
 
 // Tests to verify the proper use of auto where the init variable type and the
 // initializer type differ or are mostly the same except for const qualifiers.
 void different_type() {
   // Ss.begin() returns a type 'iterator' which is just a non-const pointer and
   // differs from const_iterator only on the const qualification.
   S Ss;
   for (S::const_iterator It = Ss.begin(), E = Ss.end(); It != E; ++It) {
     printf("s has value %d\n", (*It).X);
   }
   // CHECK-MESSAGES: :[[@LINE-3]]:3: warning: use range-based for loop instead
   // CHECK-FIXES: for (auto It : Ss)
   // CHECK-FIXES-NEXT: printf("s has value %d\n", It.X);
 
   S *Ps;
   for (S::const_iterator It = Ps->begin(), E = Ps->end(); It != E; ++It) {
     printf("s has value %d\n", (*It).X);
   }
   // CHECK-MESSAGES: :[[@LINE-3]]:3: warning: use range-based for loop instead
   // CHECK-FIXES: for (auto P : *Ps)
   // CHECK-FIXES-NEXT: printf("s has value %d\n", P.X);
 
   dependent<int> V;
   for (dependent<int>::const_iterator It = V.begin(), E = V.end();
        It != E; ++It) {
     printf("Fibonacci number is %d\n", *It);
   }
   // CHECK-MESSAGES: :[[@LINE-4]]:3: warning: use range-based for loop instead
   // CHECK-FIXES: for (int It : V)
   // CHECK-FIXES-NEXT: printf("Fibonacci number is %d\n", It);
 
   for (dependent<int>::const_iterator It(V.begin()), E = V.end();
        It != E; ++It) {
     printf("Fibonacci number is %d\n", *It);
   }
   // CHECK-MESSAGES: :[[@LINE-4]]:3: warning: use range-based for loop instead
   // CHECK-FIXES: for (int It : V)
   // CHECK-FIXES-NEXT: printf("Fibonacci number is %d\n", It);
 }
 
 // Tests to ensure that an implicit 'this' is picked up as the container.
 // If member calls are made to 'this' within the loop, the transform becomes
 // risky as these calls may affect state that affects the loop.
 class C {
 public:
   typedef MutableVal *iterator;
   typedef const MutableVal *const_iterator;
 
   iterator begin();
   iterator end();
   const_iterator begin() const;
   const_iterator end() const;
 
   void doSomething();
   void doSomething() const;
 
   void doLoop() {
     for (iterator I = begin(), E = end(); I != E; ++I)
       (void) *I;
     // CHECK-MESSAGES: :[[@LINE-2]]:5: warning: use range-based for loop instead
     // CHECK-FIXES: for (auto & I : *this)
 
     for (iterator I = C::begin(), E = C::end(); I != E; ++I)
       (void) *I;
     // CHECK-MESSAGES: :[[@LINE-2]]:5: warning: use range-based for loop instead
     // CHECK-FIXES: for (auto & I : *this)
 
     for (iterator I = begin(), E = end(); I != E; ++I) {
       (void) *I;
       doSomething();
     }
 
     for (iterator I = begin(); I != end(); ++I)
       (void) *I;
     // CHECK-MESSAGES: :[[@LINE-2]]:5: warning: use range-based for loop instead
     // CHECK-FIXES: for (auto & I : *this)
 
     for (iterator I = begin(); I != end(); ++I) {
       (void) *I;
       doSomething();
     }
   }
 
   void doLoop() const {
     for (const_iterator I = begin(), E = end(); I != E; ++I)
       (void) *I;
     // CHECK-MESSAGES: :[[@LINE-2]]:5: warning: use range-based for loop instead
     // CHECK-FIXES: for (auto I : *this)
 
     for (const_iterator I = C::begin(), E = C::end(); I != E; ++I)
       (void) *I;
     // CHECK-MESSAGES: :[[@LINE-2]]:5: warning: use range-based for loop instead
     // CHECK-FIXES: for (auto I : *this)
 
     for (const_iterator I = begin(), E = end(); I != E; ++I) {
       (void) *I;
       doSomething();
     }
   }
 };
 
 class C2 {
 public:
   typedef MutableVal *iterator;
 
   iterator begin() const;
   iterator end() const;
 
   void doLoop() {
     // The implicit 'this' will have an Implicit cast to const C2* wrapped
     // around it. Make sure the replacement still happens.
     for (iterator I = begin(), E = end(); I != E; ++I)
       (void) *I;
     // CHECK-MESSAGES: :[[@LINE-2]]:5: warning: use range-based for loop instead
     // CHECK-FIXES: for (auto & I : *this)
   }
 };
 
 } // namespace Iterator
 
 namespace PseudoArray {
 
 const int N = 6;
 dependent<int> V;
 dependent<int> *Pv;
 const dependent<NonTriviallyCopyable> Constv;
 const dependent<NonTriviallyCopyable> *Pconstv;
 
 transparent<dependent<int>> Cv;
+dependent_derived<int> VD;
 
 void f() {
   int Sum = 0;
   for (int I = 0, E = V.size(); I < E; ++I) {
     printf("Fibonacci number is %d\n", V[I]);
     Sum += V[I] + 2;
   }
   // CHECK-MESSAGES: :[[@LINE-4]]:3: warning: use range-based for loop instead
   // CHECK-FIXES: for (int I : V)
   // CHECK-FIXES-NEXT: printf("Fibonacci number is %d\n", I);
   // CHECK-FIXES-NEXT: Sum += I + 2;
 
   for (int I = 0, E = V.size(); I < E; ++I) {
     printf("Fibonacci number is %d\n", V.at(I));
     Sum += V.at(I) + 2;
   }
   // CHECK-MESSAGES: :[[@LINE-4]]:3: warning: use range-based for loop instead
   // CHECK-FIXES: for (int I : V)
   // CHECK-FIXES-NEXT: printf("Fibonacci number is %d\n", I);
   // CHECK-FIXES-NEXT: Sum += I + 2;
 
   for (int I = 0, E = Pv->size(); I < E; ++I) {
     printf("Fibonacci number is %d\n", Pv->at(I));
     Sum += Pv->at(I) + 2;
   }
   // CHECK-MESSAGES: :[[@LINE-4]]:3: warning: use range-based for loop instead
   // CHECK-FIXES: for (int I : *Pv)
   // CHECK-FIXES-NEXT: printf("Fibonacci number is %d\n", I);
   // CHECK-FIXES-NEXT: Sum += I + 2;
 
   // This test will fail if size() isn't called repeatedly, since it
   // returns unsigned int, and 0 is deduced to be signed int.
   // FIXME: Insert the necessary explicit conversion, or write out the types
   // explicitly.
   for (int I = 0; I < Pv->size(); ++I) {
     printf("Fibonacci number is %d\n", (*Pv).at(I));
     Sum += (*Pv)[I] + 2;
   }
   // CHECK-MESSAGES: :[[@LINE-4]]:3: warning: use range-based for loop instead
   // CHECK-FIXES: for (int I : *Pv)
   // CHECK-FIXES-NEXT: printf("Fibonacci number is %d\n", I);
   // CHECK-FIXES-NEXT: Sum += I + 2;
 
   for (int I = 0; I < Cv->size(); ++I) {
     printf("Fibonacci number is %d\n", Cv->at(I));
     Sum += Cv->at(I) + 2;
   }
   // CHECK-MESSAGES: :[[@LINE-4]]:3: warning: use range-based for loop instead
   // CHECK-FIXES: for (int I : *Cv)
   // CHECK-FIXES-NEXT: printf("Fibonacci number is %d\n", I);
   // CHECK-FIXES-NEXT: Sum += I + 2;
 
   for (int I = 0, E = V.size(); E > I; ++I) {
     printf("Fibonacci number is %d\n", V[I]);
     Sum += V[I] + 2;
   }
   // CHECK-MESSAGES: :[[@LINE-4]]:3: warning: use range-based for loop instead
   // CHECK-FIXES: for (int I : V)
   // CHECK-FIXES-NEXT: printf("Fibonacci number is %d\n", I);
   // CHECK-FIXES-NEXT: Sum += I + 2;
 
   for (int I = 0, E = V.size(); I != E; ++I) {
     printf("Fibonacci number is %d\n", V[I]);
     Sum += V[I] + 2;
   }
   // CHECK-MESSAGES: :[[@LINE-4]]:3: warning: use range-based for loop instead
   // CHECK-FIXES: for (int I : V)
   // CHECK-FIXES-NEXT: printf("Fibonacci number is %d\n", I);
   // CHECK-FIXES-NEXT: Sum += I + 2;
 
   for (int I = 0, E = V.size(); E != I; ++I) {
     printf("Fibonacci number is %d\n", V[I]);
     Sum += V[I] + 2;
   }
   // CHECK-MESSAGES: :[[@LINE-4]]:3: warning: use range-based for loop instead
   // CHECK-FIXES: for (int I : V)
   // CHECK-FIXES-NEXT: printf("Fibonacci number is %d\n", I);
   // CHECK-FIXES-NEXT: Sum += I + 2;
+
+  for (int I = 0, E = VD.size(); E != I; ++I) {
+    printf("Fibonacci number is %d\n", VD[I]);
+    Sum += VD[I] + 2;
+  }
+  // CHECK-MESSAGES: :[[@LINE-4]]:3: warning: use range-based for loop instead
+  // CHECK-FIXES: for (int I : VD)
+  // CHECK-FIXES-NEXT: printf("Fibonacci number is %d\n", I);
+  // CHECK-FIXES-NEXT: Sum += I + 2;
 }
 
 // Ensure that 'const auto &' is used with containers of non-trivial types.
 void constness() {
   int Sum = 0;
   for (int I = 0, E = Constv.size(); I < E; ++I) {
     printf("Fibonacci number is %d\n", Constv[I].X);
     Sum += Constv[I].X + 2;
   }
   // CHECK-MESSAGES: :[[@LINE-4]]:3: warning: use range-based for loop instead
   // CHECK-FIXES: for (const auto & I : Constv)
   // CHECK-FIXES-NEXT: printf("Fibonacci number is %d\n", I.X);
   // CHECK-FIXES-NEXT: Sum += I.X + 2;
 
   for (int I = 0, E = Constv.size(); I < E; ++I) {
     printf("Fibonacci number is %d\n", Constv.at(I).X);
     Sum += Constv.at(I).X + 2;
   }
   // CHECK-MESSAGES: :[[@LINE-4]]:3: warning: use range-based for loop instead
   // CHECK-FIXES: for (const auto & I : Constv)
   // CHECK-FIXES-NEXT: printf("Fibonacci number is %d\n", I.X);
   // CHECK-FIXES-NEXT: Sum += I.X + 2;
 
   for (int I = 0, E = Pconstv->size(); I < E; ++I) {
     printf("Fibonacci number is %d\n", Pconstv->at(I).X);
     Sum += Pconstv->at(I).X + 2;
   }
   // CHECK-MESSAGES: :[[@LINE-4]]:3: warning: use range-based for loop instead
   // CHECK-FIXES: for (const auto & I : *Pconstv)
   // CHECK-FIXES-NEXT: printf("Fibonacci number is %d\n", I.X);
   // CHECK-FIXES-NEXT: Sum += I.X + 2;
 
   // This test will fail if size() isn't called repeatedly, since it
   // returns unsigned int, and 0 is deduced to be signed int.
   // FIXME: Insert the necessary explicit conversion, or write out the types
   // explicitly.
   for (int I = 0; I < Pconstv->size(); ++I) {
     printf("Fibonacci number is %d\n", (*Pconstv).at(I).X);
     Sum += (*Pconstv)[I].X + 2;
   }
   // CHECK-MESSAGES: :[[@LINE-4]]:3: warning: use range-based for loop instead
   // CHECK-FIXES: for (const auto & I : *Pconstv)
   // CHECK-FIXES-NEXT: printf("Fibonacci number is %d\n", I.X);
   // CHECK-FIXES-NEXT: Sum += I.X + 2;
 }
 
 void constRef(const dependent<int>& ConstVRef) {
   int sum = 0;
   // FIXME: This does not work with size_t (probably due to the implementation
   // of dependent); make dependent work exactly like a std container type.
   for (int I = 0; I < ConstVRef.size(); ++I) {
     sum += ConstVRef[I];
   }
   // CHECK-MESSAGES: :[[@LINE-3]]:3: warning: use range-based for loop instead
   // CHECK-FIXES: for (int I : ConstVRef)
   // CHECK-FIXES-NEXT: sum += I;
 
   for (auto I = ConstVRef.begin(), E = ConstVRef.end(); I != E; ++I) {
     sum += *I;
   }
   // CHECK-MESSAGES: :[[@LINE-3]]:3: warning: use range-based for loop instead
   // CHECK-FIXES: for (int I : ConstVRef)
   // CHECK-FIXES-NEXT: sum += I;
 }
 
 // Check for loops that don't mention containers.
 void noContainer() {
   for (auto I = 0; I < V.size(); ++I) {
   }
 
   for (auto I = 0; I < V.size(); ++I)
     ;
 }
 
 struct NoBeginEnd {
   unsigned size() const;
   unsigned& operator[](int);
   const unsigned& operator[](int) const;
 };
 
 struct NoConstBeginEnd {
   NoConstBeginEnd();
   unsigned size() const;
   unsigned* begin();
   unsigned* end();
   unsigned& operator[](int);
   const unsigned& operator[](int) const;
 };
 
 struct ConstBeginEnd {
   ConstBeginEnd();
   unsigned size() const;
   unsigned* begin() const;
   unsigned* end() const;
   unsigned& operator[](int);
   const unsigned& operator[](int) const;
 };
 
 // Shouldn't transform pseudo-array uses if the container doesn't provide
 // begin() and end() of the right const-ness.
 void NoBeginEndTest() {
   NoBeginEnd NBE;
   for (unsigned I = 0, E = NBE.size(); I < E; ++I)
     printf("%d\n", NBE[I]);
 
   const NoConstBeginEnd Const_NCBE;
   for (unsigned I = 0, E = Const_NCBE.size(); I < E; ++I)
     printf("%d\n", Const_NCBE[I]);
 
   ConstBeginEnd CBE;
   for (unsigned I = 0, E = CBE.size(); I < E; ++I)
     printf("%d\n", CBE[I]);
   // CHECK-MESSAGES: :[[@LINE-2]]:3: warning: use range-based for loop instead
   // CHECK-FIXES: for (unsigned int I : CBE)
   // CHECK-FIXES-NEXT: printf("%d\n", I);
 
   const ConstBeginEnd Const_CBE;
   for (unsigned I = 0, E = Const_CBE.size(); I < E; ++I)
     printf("%d\n", Const_CBE[I]);
   // CHECK-MESSAGES: :[[@LINE-2]]:3: warning: use range-based for loop instead
   // CHECK-FIXES: for (unsigned int I : Const_CBE)
   // CHECK-FIXES-NEXT: printf("%d\n", I);
 }
 
 struct DerefByValue {
   DerefByValue();
   struct iter { unsigned operator*(); };
   unsigned size() const;
   iter begin();
   iter end();
   unsigned operator[](int);
 };
 
 void derefByValueTest() {
   DerefByValue DBV;
   for (unsigned I = 0, E = DBV.size(); I < E; ++I) {
     printf("%d\n", DBV[I]);
   }
   // CHECK-MESSAGES: :[[@LINE-3]]:3: warning: use range-based for loop instead
   // CHECK-FIXES: for (unsigned int I : DBV)
   // CHECK-FIXES-NEXT: printf("%d\n", I);
 
   for (unsigned I = 0, E = DBV.size(); I < E; ++I) {
     auto f = [DBV, I]() {};
     printf("%d\n", DBV[I]);
   }
   // CHECK-MESSAGES: :[[@LINE-4]]:3: warning: use range-based for loop instead
   // CHECK-FIXES: for (unsigned int I : DBV)
   // CHECK-FIXES-NEXT: auto f = [DBV, &I]() {};
   // CHECK-FIXES-NEXT: printf("%d\n", I);
 }
 
 void fundamentalTypesTest() {
   const int N = 10;
   bool Bools[N];
   for (int i = 0; i < N; ++i)
     printf("%d", Bools[i]);
   // CHECK-MESSAGES: :[[@LINE-2]]:3: warning: use range-based for loop instead
   // CHECK-FIXES: for (bool Bool : Bools)
 
   int Ints[N];
   unsigned short int Shorts[N];
   for (int i = 0; i < N; ++i)
     printf("%d", Shorts[i]);
   // CHECK-MESSAGES: :[[@LINE-2]]:3: warning: use range-based for loop instead
   // CHECK-FIXES: for (unsigned short Short : Shorts)
 
   signed long Longs[N];
   for (int i = 0; i < N; ++i)
     printf("%d", Longs[i]);
   // CHECK-MESSAGES: :[[@LINE-2]]:3: warning: use range-based for loop instead
   // CHECK-FIXES: for (long Long : Longs)
 
   long long int LongLongs[N];
   for (int i = 0; i < N; ++i)
     printf("%d", LongLongs[i]);
   // CHECK-MESSAGES: :[[@LINE-2]]:3: warning: use range-based for loop instead
   // CHECK-FIXES: for (long long LongLong : LongLongs)
 
   char Chars[N];
   for (int i = 0; i < N; ++i)
     printf("%d", Chars[i]);
   // CHECK-MESSAGES: :[[@LINE-2]]:3: warning: use range-based for loop instead
   // CHECK-FIXES: for (char Char : Chars)
 
   wchar_t WChars[N];
   for (int i = 0; i < N; ++i)
     printf("%d", WChars[i]);
   // CHECK-MESSAGES: :[[@LINE-2]]:3: warning: use range-based for loop instead
   // CHECK-FIXES: for (wchar_t WChar : WChars)
 
   float Floats[N];
   for (int i = 0; i < N; ++i)
     printf("%d", Floats[i]);
   // CHECK-MESSAGES: :[[@LINE-2]]:3: warning: use range-based for loop instead
   // CHECK-FIXES: for (float Float : Floats)
 
   double Doubles[N];
   for (int i = 0; i < N; ++i)
     printf("%d", Doubles[i]);
   // CHECK-MESSAGES: :[[@LINE-2]]:3: warning: use range-based for loop instead
   // CHECK-FIXES: for (double Double : Doubles)
 }
 
 } // namespace PseudoArray
